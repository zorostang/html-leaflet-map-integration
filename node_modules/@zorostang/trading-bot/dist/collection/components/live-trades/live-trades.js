import { h } from '@stencil/core';
import throttle from 'lodash/throttle';
// import random from 'lodash/random'
export class LiveTrades {
    constructor() {
        /** The instrument to get trade data from */
        this.instrument = '';
        this.updateLastTrade = (newVal, cb) => {
            const lastTrade = JSON.parse(newVal);
            console.log(lastTrade);
            if (lastTrade.data && lastTrade.data[0].symbol === this.instrument) {
                cb(lastTrade.data[0]);
            }
        };
        this.throttledUpdate = throttle(this.updateLastTrade, 33);
        this.connect = () => {
            this.ws = new WebSocket("wss://www.bitmex.com/realtime");
            this.ws.onopen = () => {
                // connection opened
                // default to XBTUSD if none given
                this.instrument = this.instrument ? this.instrument : 'XBTUSD';
                this.ws.send(JSON.stringify({
                    op: "subscribe",
                    args: `trade:${this.instrument}`
                })); // send a message
            };
            this.ws.onmessage = e => {
                // console.log(e.data)
                this.state = e.data; // bitmex returns stringified json
            };
            this.ws.onerror = (e) => {
                // an error occurred
                console.log(e);
            };
            this.ws.onclose = (e) => {
                // connection closed
                console.log(e.code, e.reason);
            };
        };
        this.getFontSize = () => {
            // todo: computes a font sise relative the spread of the last trade
            const size = 1;
            return `${size}rem`;
        };
        this.getColor = () => {
            // computes the color relative to last tick direction
            if (this.lastTrade) {
                switch (this.lastTrade.tickDirection) {
                    case 'ZeroPlusTick':
                        return 'green';
                    case 'ZeroMinusTick':
                        return 'red';
                    case 'PlusTick':
                        return 'green';
                    case 'MinusTick':
                        return 'red';
                    default:
                        console.log(this.lastTrade.tickDirection);
                }
            }
        };
        this.style = () => ({
            fontSize: this.getFontSize(),
            color: this.getColor()
        });
    }
    watchHandler(newVal) {
        // convert stringified JSON into an object we can use
        this.throttledUpdate(newVal, (val) => {
            this.lastTrade = Object.assign({}, val);
        });
    }
    handleInstrumentChange(newVal) {
        console.log(newVal);
        this.ws.send(JSON.stringify({
            op: "subscribe",
            args: `trade:${this.instrument}`
        }));
    }
    componentWillLoad() {
        this.connect();
    }
    render() {
        if (!this.lastTrade)
            return null;
        return h("div", null,
            this.instrument,
            " is trading at: ",
            h("span", { style: this.style() }, this.lastTrade.price));
    }
    static get is() { return "live-trades"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() { return {
        "$": ["live-trades.css"]
    }; }
    static get styleUrls() { return {
        "$": ["live-trades.css"]
    }; }
    static get properties() { return {
        "instrument": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The instrument to get trade data from"
            },
            "attribute": "instrument",
            "reflect": false,
            "defaultValue": "''"
        }
    }; }
    static get states() { return {
        "state": {},
        "lastTrade": {}
    }; }
    static get watchers() { return [{
            "propName": "state",
            "methodName": "watchHandler"
        }, {
            "propName": "instrument",
            "methodName": "handleInstrumentChange"
        }]; }
}
